{"pages":[{"title":"Hi-Framework Docs","text":"What is Hi-Framework? An Ajax MVC Java EE Framework based on AngularJS Say &quot;Hello&quot; to your Client-Side","tags":"","url":"index.html"},{"title":"Introduction","text":"Why did we build Hi-Framework? We wanted to bring the simplicity of AngularJS to the JAVA EE development environment and allow people to have fun developing fully AJAX Web apps in Java. The client-side is coded in pure HTML and JavaScript. There is no expression language, only angular. Our mission was to give back to the java Web developers their client-side. Sometimes you just need to explore all the client-side power and neither JSF nor ZK help you in the process. They add a very big layer on top of your application in a way that it feels heavy and hard to customize. They weren\u00e2\u0080\u0099t built for fancy UI web applications. We wanted developers to use angular with Java EE without having to build Rest APIs, or issue HTTP Requests. One of the benefits of the approach we used is that the views files aren\u00e2\u0080\u0099t processed on server-side, they are pure HTML, meaning that, they can be cached easily on the client-side. The performance? You wont need an Ajax loader. This framework relies entirely on JAVA EE Specifications API\u00e2\u0080\u0099s like CDI and Servlet 3. Requirements JAVA (version 1.8) CDI Implementation (version 1.2)","tags":"","url":"Getting_started\/Introduction.html"},{"title":"Application structure and components","text":"Hi-Framework is not concerned about how you manage your java source files. It is only concerned about the web directory. The web directory structure |-- Web |-- WEB-INF |-- hi.xml |-- webroot |-- views |-- templateName.html |-- templateName.js If you are familiar with JavaEE web applications you might have noticed that Hi-framework does not change the structure, it just adds few directories and a configuration file within WEB-INF directory. Lets now understand the purpose of each file\/directory. WEB-INF\/hi.xml This is the framework configuration file. Your application is configured here. webroot This is the assets home. The directory holds scripts, stylesheets, images and all the files that should be publicly accessible. views This is where the view files live. A View is displayed uppon Controller invocation as stated by MVC pattern. templateName.js and templateName.html This templateName.html file is the container within which the view files are displayed. The templateName.js listens some events that will be detailled later. NOTE: You are completely free to add your own directories and files according to your needs, as long as the directory structure demanded by the framework remains in place.","tags":"","url":"Getting_started\/Application_structure_and_components.html"},{"title":"Preparing the environment","text":"Setting up the maven project Hi-Framework is not in maven central repository, meaning that you have to add our maven repository to your POM so that the dependency can be resolved. The following snippet should be added to yout POM file: &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;talk-code&lt;\/id&gt; &lt;name&gt;maven-repo&lt;\/name&gt; &lt;url&gt;https:\/\/github.com\/talk-code\/maven-repo\/raw\/master&lt;\/url&gt; &lt;\/repository&gt; &lt;\/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mz.hi.framework&lt;\/groupId&gt; &lt;artifactId&gt;hi-web&lt;\/artifactId&gt; &lt;version&gt;1.0-beta-SNAPSHOT&lt;\/version&gt; &lt;\/dependency&gt; &lt;\/dependencies&gt; If you already have a repositories element on your POM file, make sure you only copy the repository into your POM, the same applies to the dependencies and dependency elements. Adding Mandatory JavaEE dependencies to maven project CDI 1.2 Implementation Hi-Framework depends on the CDI API. There should be a CDI Implementation (version 1.2) in your classpath when attempting to deploy the application. If you are using Glassfish, make sure it has the correct implementation before you run into trouble. If your Glassfish (or any other JavaEE server) is not shipped with any CDI 1.2 implementation, we recommed you to add the JBoss Weld 2.1 implementation of CDI to your application's classpath. This can be done using the following maven dependency: &lt;dependency&gt; &lt;groupId&gt;org.jboss.weld&lt;\/groupId&gt; &lt;artifactId&gt;weld-core&lt;\/artifactId&gt; &lt;version&gt;2.1.0.Final&lt;\/version&gt; &lt;\/dependency&gt;","tags":"","url":"Getting_started\/The Hello_World_App\/Preparing_the_environment.html"},{"title":"Creating the Hello controller and world view","text":"Controller definition Before we go any further, lets define a Controller. The user interacts with the system navigating through URLs. Earch url, is used to retrieve interactive content and points to an action of a Controller. The URLs format is: controller-name\/action-name. A controller is a managed bean that extends the mz.co.hi.web.mvc.Controller class. All public methods of a controller are considered actions, meaning they are accessible via URL. What we want to do now, is to create a web application that displays a Hello World message after entering the URL hello\/world on the browser. Lets see how the Hello.java controller file should look like: package my.controllers; \/\/your controllers's package can have any name import mz.co.hi.web.mvc.Controller; import mz.co.hi.web.mvc.exceptions.MvcException; import javax.enterprise.context.ApplicationScoped; @ApplicationScoped public class Hello extends Controller { public void world() throws MvcException{ this.callView(); } } The instruction this.callView() basically tells Hi-Framework to load a view and display it to the user. A view should be created in order to have that line of code executing successfully. So, how do you create a view? The View It is composed by two files: a html file and its correspondent javascript file. These two files should have the same name as the action that calls them, and they must be placed under the views directory, according to the following directories structure: |-- Web |-- views |-- hello |-- world.html |-- world.js Notice that we created a directory with the controller's name &quot;hello&quot; and then we created two files under that directory. That two files represent the view. NOTE: the view directories must be a mirror of the url. Meaning: 1. no capital letters 2. camelCase is converted to hyphen separed words. Ex: hiFramework = hi-framework HiFramework = hi-framework world.html This file contains markup content to be loaded and renderized on browser for the hello\/world URL. &lt;div&gt; &lt;h1&gt;Hello world&lt;\/h1&gt; &lt;\/div&gt; world.js This file contains javascript code that manipulates the markup content, before, during and after its renderization. Hi.view(function($scope){ \/\/Body empty for now });","tags":"","url":"Getting_started\/The Hello_World_App\/Creating_the_Hello_controller_and_world_view.html"},{"title":"Creating the template","text":"Template definition Template is what surrounds your views. The views are diplayed within templates. On facebook for example, you can notice that the top bar is present in every single page. Thats because it is part of the facebook template. A template has a defined area within which, the views are displayed. Each template in Hi, is composed by two files: html and javascript, same as views. Hi-Framework allows you to have more than one template and switch between them as you need. For now, lets focus on creating our default template. The name of the template we are going to create is index, tha's because Hi recognises index as the default template. You may a bunch of templates with other names but one of them must be named &quot;index&quot;. The html file of a template is responsible for loading every single script,image,stylesheet or any other asset the application depends on. Views should not include scripts or sytlesheets. The template files should be placed inside the web root(not &quot;webroot&quot;) directory, being direct childs of it. Lets see how our web directory looks like, after creating the index template files: |-- Web |-- WEB-INF |-- web.xml |-- hi.xml |-- webroot |-- views |-- index.html |-- index.js Let's see how these files are composed. index.html This is the markup file of our default template. This file has to include at least 3 things jquery script (greater or equal to 1.10 ) The hi-framework script The place where views should be included. Thiss next code block will show you how to do it: &lt;html&gt; &lt;head&gt; &lt;title&gt;Hi-Framework | Getting started&lt;\/title&gt; &lt;!--The jquery script--&gt; &lt;script src=&quot;https:\/\/code.jquery.com\/jquery-3.0.0.min.js&quot;&gt;&lt;\/script&gt; &lt;!--The hi-framework script--&gt; &lt;script src=&quot;hi-es5.js&quot;&gt;&lt;\/script&gt; &lt;\/head&gt; &lt;body&gt; Template content comes here &lt;!--The views will placed inside this div--&gt; &lt;div id=&quot;view_content&quot;&gt;{{view_content}}&lt;\/div&gt; &lt;\/body&gt; &lt;\/html&gt; IMPORTANT RULE: The jquery script should always be included before the hi-framework script and they should both be placed as childs of head element. Feel free to add your own scrips, stylesheets and anything else you want. This a normal html file. Make sure you place your assets (scripts, stylesheets, images) under the webroot directory. The internal structure of the webroot directory is on you. Create as many folders and files as you need. If you are going to download the jquery to your application, you should store it under the webroot directory, in a subdirectory of your own choice. For example: |-- Web |-- WEB-INF |-- web.xml |-- hi.xml |-- webroot |-- js |-- jquery-3.0.0.min.js |-- views |-- index.html |-- index.js You would then have to change the jquery script path in your index.html file to: &lt;script src=&quot;webroot\/js\/jquery-3.0.0.min.js&quot;&gt;&lt;\/script&gt; You can load any asset in your template. Just make sure you put the right path, starting with &quot;webroot&quot; and following the directories strucuture. index.js This file is designated template controller. Lets not get into too much details about this now. What matters most at this step is the content of the file, which is: Hi.template({ \/\/Empty body for now });","tags":"","url":"Getting_started\/The Hello_World_App\/Creating_the_template.html"},{"title":"Creating the config file","text":"What is the configuration file? Its a XML file that configures the behavoir of Hi-Framework regarding your application. The configuration file for our Hello world app &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;app xmlns=&quot;http:\/\/hi.co.mz\/XMLSchema&quot; xmlns:xsi=&quot;http:\/\/www.w3.org\/2001\/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http:\/\/hi.co.mz\/XMLSchema https:\/\/talk-code.github.io\/releases\/ns\/hi-1.0.xsd&quot;&gt; &lt;web&gt; &lt;welcome-url&gt;hello\/world&lt;\/welcome-url&gt; &lt;\/web&gt; &lt;\/app&gt; There is no mandatory configuration to run your Hi app. In order to make the root URL of your application display a specific view, you should configure your welcome-url as it's done in the snipped above. Check bellow some assumptions Hi makes: The default template is named index The default directory for views is named views Where is the config file located? The configuration file should be placed under the WEB-INF directory and must have the name hi.xml. What else? Our web application is ready for reployment. But we may want review our files and directories structure. Putting it all together, we must have : |-- Web |-- WEB-INF |-- hi.xml |-- webroot |-- js |-- jquery-3.0.0.min.js |-- views |-- hello |-- world.html |-- world.js |-- index.html |-- index.js |-- java [--] my.controlles |-- Hello.java NOTE: The configuration file is not optional. An attempt of deployment without the configuration file will result in errors. You can now build and deploy the application","tags":"","url":"Getting_started\/The Hello_World_App\/Creating_the_config_file.html"},{"title":"Testing the app","text":"BASE_URL\/Hello\/world BASE_URL is defined by your server host + port and the name of your application (context path) within the server you deployed it to. Example of BASE URL: http:\/\/localhost:8080\/app1. The full URL would be: http:\/\/localhost:8080\/app1\/hello\/world The outcome","tags":"","url":"Getting_started\/The Hello_World_App\/Testing_the_app.html"},{"title":"Navigation","text":"You wouldn't put all your business logic in a single view, would you? Lets create a new action and then figure out how can we redirect the user from one view to another. The second action Adding the action method Just add the following code fragment to the Hello controller source code file. public void second() throws MvcException{ this.callView(); } Creating the view for the new action All we have to do is: create two files under the directory views\/hello\/: |-- views |-- Hello |-- world.html |-- world.js |-- second.html |-- second.js second.html &lt;div&gt; &lt;h2&gt;Second action&lt;\/h2&gt; &lt;!--This will redirect the user to hello\/world using ajax--&gt; &lt;a href=&quot;hello\/world&quot; ajaxify&gt;Go back&lt;\/a&gt; &lt;\/div&gt; NOTE: The ajaxify attribute used above, configures the hyperlink element to perform an ajax redirect onClick. second.js Hi.view(function($scope){ }); Adding a redirect link to the views\/hello\/world.html file (method 1) The modified views\/hello\/world.html version: &lt;div&gt; &lt;h1&gt;Hello world&lt;\/h1&gt; &lt;a href=&quot;hello\/second&quot; ajaxify&gt;Go to second&lt;\/a&gt; &lt;\/div&gt; User can now navigate from hello\/world to hello\/second and vice versa. Just rebuild the application and redeploy it. Results Adding a redirect link to the views\/hello\/world.html file (method 2) Let's change again our world.html file. The modified views\/hello\/world.html version: &lt;div&gt; &lt;h1&gt;Hello world&lt;\/h1&gt; &lt;button ng-click=&quot;goToSecond()&quot;&gt;Go to second&lt;\/button&gt; &lt;\/div&gt; We basically changed our hyperlink to a button. This button calls a function named goToSecond on a click. The ng-click tag is part of AngularJS. You can consult more about Angular anywhere in the internet. Now, let's change our world.js file. The modified views\/Hello\/world.js version: . Hi.view(function($scope){ $scope.goToSecond = function(){ Hi.redirect(&quot;hello\/second&quot;); } }); We created in the $scope of our javascript view, a fuction that uses a special method called redirect witch redirects the user the same way as the first aproach. Test it! it will work the same way!","tags":"","url":"Getting_started\/Navigation.html"},{"title":"Frontiers basics","text":"The concept Frontiers are special classes that can be accessed from client-side. The methods of frontier classes are accessed as if they were declared as static. The rules Frontier classes are Managed beans (same as controllers). All frontiers must be annotated with the @Frontier annotation Frontier methods are suposed to return data. void methods are not considered frontiers methods The example frontier Example.java package my.frontiers; import javax.enterprise.context.ApplicationScoped; import java.util.HashMap; import java.util.Map; import mz.co.hi.web.meta.Frontier; @Frontier @ApplicationScoped public class Example { public String basic() { return &quot;This is a frontier message&quot;; } public Map increment(int value) { Map map = new HashMap(); map.put(&quot;incremented&quot;,value+1); return map; } } We created a frontier named Example and within it two methods: basic and increment. Both methods return messages, basic returns a String with a static message and increment a java.util.Map with a dynamic one. We added Example.java to a package named frontiers that resides inside a package named my. Let's see how do we invoke these methods. Invoking the frontier methods from javascript To invoke frontier methods, we have to do as following from anypoint in your javascript: FrontierName.frontierMethod().try(function(result){ console.log(result.message); }); Calling the example frontier from world.js view Let's go back to our world.js view and take a look at it: Hi.view(function($scope){ $scope.goToSecond = function(){ Hi.redirect(&quot;hello\/second&quot;); } }); So, what we have here? Remember: Javascript views handle events fired by markup elements in html views In the snippet above, we can see a function named goToSecond. Now we will change the behavior of this function and make it call a frontier method. Let's change the world.js view and make it look like this: Hi.view(function($scope){ $scope.goToSecond = function(){ Example.basic().try(function(result){ alert(result); }); } }); Now, if you click the button Go to second in the route hello\/world, instead of redirecting your application, the click event will show an alert with the message returnerd by the basic method of the example frontier Well, now you can test your application. But before, read the following tips: Tips Rebuild and redeploy your application Everytime you change a frontier Reload the page after redeployment. Passing params on a frontier method call Adding a button to a view html &lt;button ng-click=&quot;frontierMessage(5)&quot;&gt;Click on me&lt;\/button&gt; Adding the frontierTest function The frontierMessage function shoud be added to the $scope object of the view where the button element was placed. If you dont understand anything about angular-js scopes, please follow this link to get started and please come back only after understanding the basics. Hi.view(function($scope){ $scope.frontierMessage = function(number){ Example.increment(number).try(function(result){ alert(result.incremented); }); }; }); Feel free to make any changes to your app at this point. Remeber the tips. Use any other framework for any other purprose. For a deep understanding, read the Core Concepts ahead. ;)","tags":"","url":"Getting_started\/Frontiers_basics.html"},{"title":"Core Concepts","text":"Welcome to our Core Concepts Here you will have a understanting of every component in Hi-Framework. Everthging explained in the Getting Started section will also be explained here but, with more details and complexity. If you didn't read the Getting Started you may have some big issues here. Ready to move on? Press \"Next\" and dive into Controllers -Controllers -Views -Templates -Frontiers -FrontEnd -i18n -Basic Configuration(DEV MODE\/PRODUCTION MODE)","tags":"","url":"Core_Concepts\/index.html"},{"title":"Controllers","text":"By now, you already know controllers. Definition Controllers are part of the MVC-Pattern. In Hi, Controllers are responsible to handle requests made by the browser's URL and decide to call or not a it's views. A controller is a managed bean that extends the mz.co.hi.web.mvc.Controller class. All public methods of a controller are considered actions, meaning they are accessible via URL. Actions Actions are Controller methods. They are responsible for calling the views. They comunicate with your server-resources and pass data to your client-side on demand. The rules Controllers classes are Managed beans Controllers extend the mz.co.hi.web.mvc.Controller class Actions must be void (Diferrent from Frontier methods) Convetions Naming Controllers Since Controllers are Java Classes, we recommend you to name them as the best pratices say you should name Java Classes. See Examples: Hello, HiWorld, HiTeam Naming Actions Methods must follow the camelCase pattern No underscore or hyphen will be accepted The Example Controller package my.controllers; \/\/your controllers's package can have any name import mz.co.hi.web.mvc.Controller; import mz.co.hi.web.mvc.exceptions.MvcException; import javax.enterprise.context.ApplicationScoped; @ApplicationScoped public class Example extends Controller { public void myAction() throws MvcException{ this.callView(); } } In the snipped above, we have a Controller named &quot;Example&quot; and How to pass data to views? How to get passed data from params? How to send data to template? -Injecting FrontEnd;","tags":"","url":"Core_Concepts\/Controllers.html"},{"title":"Advanced Stuff","text":"Welcome Web Tunning Views Cathing Workflows of Perfomance","tags":"","url":"Advanced_Stuff\/index.html"},{"title":"FAQS","text":"Can Hi be integrated with other Template Engines rather than Angular? Not for now. But, Thats the plan. Who built Hi? A group of two very ambitious african coders. You can read about them here Does Hi implement JSF's binding mechanism? Nop. It don't and it never will. Why? Because that mechanism breaks the concept of retunrning the client-side to the developers care. is Hi safe? Safe enought. You can see our techniques here. If you find some other breaches, let us know clicing here What is Hi-List? It's a plugin that helps you manage large data in Hi Framework. They are other plugin available. Just consult our website","tags":"","url":"FAQS\/index.html"}]}